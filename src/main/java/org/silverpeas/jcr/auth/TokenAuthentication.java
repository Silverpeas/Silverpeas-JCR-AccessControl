/*
 * Copyright (C) 2000 - 2019 Silverpeas
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * As a special exception to the terms and conditions of version 3.0 of
 * the GPL, you may redistribute this Program in connection with Free/Libre
 * Open Source Software ("FLOSS") applications as described in Silverpeas's
 * FLOSS exception.  You should have received a copy of the text describing
 * the FLOSS exception, and it is also available here:
 * "http://www.silverpeas.org/legal/licensing"
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.silverpeas.jcr.auth;

import org.apache.jackrabbit.api.security.authentication.token.TokenCredentials;

import javax.jcr.Credentials;
import java.security.Principal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

/**
 * An authentication based upon a volatile security token. Instead of passing a login/password pair,
 * the authentication is performed against a token that was generated by Silverpeas to authorize
 * a user to access directly the JCR. This authentication mechanism should be used for WebDAV access
 * for example or to permit a user to access the JCR with its own profile whatever the domain and
 * the type of the domain to which he belongs (LDAP, SQL, ...).
 * @author mmoquillon
 */
public class TokenAuthentication extends AbstractAuthentication {

  private static final String USERID_TOKEN_ATTRIBUTE = "UserID";
  private static final String AUTHORIZED_DOCUMENT_PATH_ATTRIBUTE = "AuthorizedDocumentPath";
  private static final String IDENTIFY_USER =
      "select id, accesslevel from st_user where state = 'VALID' and login = ? and domainId = ?";
  private static final Pattern TOKEN_FORMAT = Pattern.compile("[a-zA-Z0-9]{16}+");

  /**
   * Authenticates a user by its credentials.
   * @param credentials {@code org.apache.jackrabbit.api.security.authentication.token.TokenCredentials}
   * instance in which are passed both a security token and fully qualified user identifier
   * (that is to say its login + the domain he belongs to).
   * If the credentials aren't with the expected type, then null is returned.
   * @return the principal of the authenticated user or null if the credentials are not supported
   * by this authentication mechanism.
   * @throws AuthenticationException if the authentication fails.
   */
  @Override
  public Principal authenticate(final Credentials credentials) throws AuthenticationException {
    Principal principal = null;
    if (credentials instanceof TokenCredentials) {
      principal = authenticate((TokenCredentials) credentials);
    }
    return principal;
  }

  /**
   * Authenticates a user with the specified token-based credentials.
   * <p>
   * It is expected the credentials carries the user identifier alongside the token. The user
   * identifier has to be in the form of USER_LOGIN'@'SILVERPEAS_DOMAIN where USER_LOGIN is the
   * login of the user to sign in Silverpeas and the SILVERPEAS_DOMAIN is the identifier of the
   * domain in Silverpeas to which the user belongs.
   * </p>
   * @param credentials the token-based credentials of a user.
   * @return the principal of the user or null if either the credentials of the user aren't taken
   * into account by this authentication mechanism.
   * @throws AuthenticationException if the authentication fails (the token isn't valid or the user
   * associated with the token isn't a valid one).
   */
  private Principal authenticate(TokenCredentials credentials) throws AuthenticationException {
    Principal principal = null;
    final String token = credentials.getToken();
    final String userID = credentials.getAttribute(USERID_TOKEN_ATTRIBUTE);
    if (matches(token, userID)) {
      final String[] userIdParts = fetchUserIdParts(userID);
      if (userIdParts != null && userIdParts.length == 2) {
        final String login = userIdParts[0];
        final String domainId = userIdParts[1];
        final SilverpeasUser user = identifySilverpeasUser(login, domainId);
        if (user != null) {
          final String authorizedDocumentPath = credentials.getAttribute(AUTHORIZED_DOCUMENT_PATH_ATTRIBUTE);
          principal = getSilverpeasUserPrincipal(user, authorizedDocumentPath);
        } else {
          // a TokenCredentials must match an existing user. Otherwise, it is considered as a
          // forbidden access
          throw new AuthenticationException("No session matching an existing user in Silverpeas");
        }
      }
    } else {
      throw new AuthenticationException("Invalid authentication token");
    }
    return principal;
  }

  /**
   * Identifies the user matching the specified login and domain. Only basic information such as
   * its identifier and the access level is get.
   * @param login the user login.
   * @param domainId the unique identifier of the domain to which the user belongs.
   * @return the user matching the specified login and domain or null.
   */
  private SilverpeasUser identifySilverpeasUser(final String login, final String domainId) {
    SilverpeasUser user = SilverpeasUser.asJcrSystemUser();
    if (!user.getLogin().equals(login) || !user.getDomainId().equals(domainId)) {
      user = null;
      try (Connection connection = openConnectionToDataSource();
           PreparedStatement statement = connection.prepareStatement(IDENTIFY_USER)) {
        statement.setString(1, login);
        statement.setInt(2, Integer.parseInt(domainId));
        try (ResultSet resultSet = statement.executeQuery()) {
          if (resultSet.next()) {
            user = new SilverpeasUser().withId(resultSet.getString("id"))
                .withDomainId(domainId)
                .withAccessLevel(resultSet.getString("accesslevel"));
          }
        }
      } catch (SQLException e) {
        Logger.getLogger(getClass().getSimpleName()).log(Level.SEVERE, e.getMessage(), e);
      }
    }
    return user;
  }

  private static boolean isDefined(String value) {
    return value != null && !value.trim().isEmpty();
  }

  private static boolean matches(String token, String userID) {
    return isDefined(token) && isDefined(userID) && TOKEN_FORMAT.matcher(token).matches();
  }
}
